package G.HeapAndBFS.Medium.KthSmallestNumberInSortedMatrix;

import java.util.HashSet;
import java.util.Objects;
import java.util.PriorityQueue;
import java.util.Set;

/**
 * https://app.laicode.io/app/problem/26
 *
 * Description
 * Given a matrix of size N x M. For each row the elements are sorted in ascending order, and for
 * each column the elements are also sorted in ascending order. Find the Kth smallest number in it.
 *
 * Assumptions
 *
 * the matrix is not null, N > 0 and M > 0
 * K > 0 and K <= N * M
 * Examples
 *
 * { {1,  3,   5,  7},
 *
 *   {2,  4,   8,   9},
 *
 *   {3,  5, 11, 15},
 *
 *   {6,  8, 13, 18} }
 *
 * the 5th smallest number is 4
 * the 8th smallest number is 6
 */

public class KthSmallestNumberInSortedMatrix {
    public int kthSmallest(int[][] matrix, int k) {
        // Write your solution here
        if (matrix == null || matrix.length == 0 ||
                matrix[0] == null || matrix[0].length == 0 || k <= 0) {
            return -1;
        }
        int rows = matrix.length;
        int cols = matrix[0].length;
        // Check for possible quick exit
        if (k == 1) {
            return matrix[0][0];
        } else if (k == rows * cols) {
            return matrix[rows - 1][cols - 1];
        }
        // Use a PQ of size k to store the smallest k elements
        // such that when the PQ is popped for the k-th time
        // we get the expected result
        // We also need to create a Cell class
        PriorityQueue<Cell> minHeap = new PriorityQueue<>(k);
        Cell first = new Cell(0, 0, matrix[0][0]);
        minHeap.offer(first);
        // Use a HashSet to keep track of the usage of Cells
        Set<Cell> visited = new HashSet<>();
        visited.add(first);
        // Do (k - 1) iterations
        // because the first Cell has already been checked
        for (int i = 0; i < k - 1; i++) {
            Cell current = minHeap.poll();
            // Expansion
            // Go to the cell below
            if (current.row + 1 < rows) {
                Cell next = new Cell(
                        current.row + 1, current.col, matrix[current.row + 1][current.col]
                );
                if (!visited.contains(next)) {
                    minHeap.offer(next);
                    visited.add(next);
                }
            }
            // Go to the cell on the right
            if (current.col + 1 < cols) {
                Cell next = new Cell(
                        current.row, current.col + 1, matrix[current.row][current.col + 1]
                );
                if (!visited.contains(next)) {
                    minHeap.offer(next);
                    visited.add(next);
                }
            }
        }
        // After offering the PQ k times, the top element is the k-th smallest in the matrix
        return minHeap.peek().val;
    }

    class Cell implements Comparable<Cell> {
        int row;
        int col;
        int val;
        public Cell(int row, int col, int val) {
            this.row = row;
            this.col = col;
            this.val = val;
        }

        @Override
        public int compareTo(Cell another) {
            // Because the val field is Integer
            // We can use Integer.compare()
            // return Integer.compare(this.val, another.val);
            // But we can also implement it manually
            if (this.val == another.val) {
                return 0;
            }
            return this.val < another.val ? -1 : 1;
        }

        // In order to use a hash table to deduplicate
        // we need to override the equals() and hashCode() methods
        // Generated by IntelliJ
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Cell)) return false;
            Cell cell = (Cell) o;
            return row == cell.row &&
                    col == cell.col &&
                    val == cell.val;
        }

        // Generated by IntelliJ
        @Override
        public int hashCode() {
            // Use the hash() method in Objects class
            // But it looks like this does not work on laicode
            // return Objects.hash(row, col, val);
            int hashResult = 17;
            hashResult = 31 * hashResult + row;
            hashResult = 31 * hashResult + col;
            hashResult = 31 * hashResult + val;
            return hashResult;
        }
    }
}
